import argparse

import sqlite3
from core import eval_valid2
import math
import random

class performace(object):
	def __init__(self,TP=0,TN=0,FP=0,FN=0):
		self.per = {'TP':TP,'TN':TN,'FP':FP,'FN':FN}
	def _div(self,x,y):
			if sum(y) == 0 and sum(x) == 0:
				return 0.0
			else:
				return sum(x)/float(sum(y))
	def acc(self):
		suc = [self.per["TP"],self.per["TN"]]
		err = [self.per["FP"],self.per["FN"]]
		all = suc + err
		return self._div(suc,all)
	
	def spf(self):
		return self._div([self.per['TN']],[self.per['TN'],self.per['FP']])
	def sns(self):
		return self._div([self.per['TP']],[self.per['TP'],self.per['FN']])
	
	def ppv(self):
		return self._div([self.per['TP']],[self.per['TP'],self.per['FP']])

	def npv(self):
		return self._div([self.per['TN']],[self.per['TN'],self.per['FN']])

	def ber(self):
		return float(self.per["FP"] + self.per["FN"])/sum(self.per.values())


	def mcc(self):
		TP,TN = self.per["TP"],self.per["TN"]
		FP,FN = self.per["FP"],self.per["FN"]
		x = (TP*TN - FP*FN)
		y = math.sqrt((TP + FN)*(TN + FP)*(TP + FP)*(TN + FN))
		if y != 0:
			return x/y
		else:
			return 0
	
	def f_value(self):
		if self.sns() == 0 and self.ppv() == 0:
			return 0
		return (2*self.sns()*self.ppv())/(self.sns()+self.ppv())

class minmax(object):
	def __init__(self,low,up,con):
		where =  " where dist = 0 or (dist >= %s and dist <= %s)" % (low,up)
		sql = "select idch,max(dec_val),min(dec_val) from valid" + where + " group by idch;"
		self.mxmn = {idch:{"max":vmax,"min":vmin} for idch,vmax,vmin in con.execute(sql)}
	def conv(self,idch,dec_val):
		vmax = self.mxmn[idch]["max"]
		vmin = self.mxmn[idch]["min"]
		return (dec_val - vmin)/(vmax - vmin)

class zscore(object):
	class sd(object):
		def __init__(self):
			self.data = None
		
		def step(self,dec_val):
			if self.data is not None:
				self.data.append(dec_val)
			else:
				self.data = [dec_val]

		def finalize(self):
			avg = sum(self.data)/float(len(self.data))
			sd = math.sqrt(sum([(i - avg)**2  for i in self.data])/float(len(self.data)))
			return sd

	def __init__(self,low,up,con):
		where =  " where dist = 0 or (dist >= %s and dist <= %s)" % (low,up)
		con.create_aggregate("sd", 1, self.sd)
		sql = "select idch,avg(dec_val),sd(dec_val) from valid" + where + " group by idch;"
		self.zscore = {idch:{"avg":avg,"sd":sd} for idch,avg,sd in con.execute(sql)}
		
	def conv(self,idch,dec_val):
		avg = self.zscore[idch]["avg"]
		sd = self.zscore[idch]["sd"]
		return (dec_val - avg)/sd


class rank(object):
	def __init__(self,low,up,con):
		#where =  " where dist = 0 or (dist >= %s and dist <= %s)" % (low,up)
		sql = "select idch,pos,dec_val from valid order by dec_val;"
		self.rank = {}
		for idch,pos,dec_val in con.execute(sql):
			if self.rank.has_key(idch):
				rank = len(self.rank[idch])
				self.rank[idch].update({pos:rank + 1})
			else:
				self.rank.update({idch:{pos:1}})
		
	def conv(self,idch,pos):
		#return self.rank[idch][pos]
		return float(self.rank[idch][pos])/len(self.rank[idch])


class valid_log(object):
	def __init__(self,name,window,c,g,low = 1,up = 1000,conv = False):
		self._dbname = eval_valid2.get_log(name,window,c,g)
		self._con = sqlite3.connect(self._dbname)
		self._low = low
		self._up = up
		
		if conv == "zscore":
			self._conv = zscore(low,up,self._con)
			self._cv_mode = conv
		elif conv == "minmax":
			self._conv = minmax(low,up,self._con)
			self._cv_mode = conv
		elif conv == "rank":
			self._conv = rank(low,up,self._con)
			self._cv_mode = conv
		else:
			self._conv = None
			self._cv_mode = None

	def __del__(self):
		self._con.close()
		
	def iter_dec(self,cnt,rev = False):
		if cnt is not None:
			sql_end = " and cnt = %s" % cnt
		else:
			sql_end = ""
		
		select = "select idch,pos,dist,dec_val from valid"
		where =  " where (dist = 0 or (dist >= %s and dist <= %s)) %s " % (self._low,self._up,sql_end)
		sql = select + where
		
		if rev:
			sql += "order by dec_val desc;"

		else:
			sql += "order by dec_val;"

		for idch,pos,dist,dec_val in self._con.execute(sql):
			if self._conv is not None:
				if self._cv_mode == "rank":
					dec_val = self._conv.conv(idch,pos)
				else:
					dec_val = self._conv.conv(idch,dec_val)
			yield idch,pos,dist,dec_val

	def iter_dec2(self,cnt,rev = False):
		# For Bugg
		if cnt is not None:
			sql_end = " and cnt = %s" % cnt
		else:
			sql_end = ""
		
		select = "select idch,pos,dist,dec_val,cnt from valid"
		where =  " where (dist = 0 or (dist >= %s and dist <= %s)) %s " % (self._low,self._up,sql_end)
		sql = select + where
		
		if rev:
			sql += "order by dec_val desc;"

		else:
			sql += "order by dec_val;"

		for idch,pos,dist,dec_val,_cnt in self._con.execute(sql):
			if self._conv is not None:
				if self._cv_mode == "rank":
					dec_val = self._conv.conv(idch,pos)
				else:
					dec_val = self._conv.conv(idch,dec_val)
				#dec_val = self._conv.conv(idch,dec_val)
			#f = lambda x,cnt: x*-1 if cnt == 3 else x
			#dec_val = f(dec_val,_cnt)
			yield idch,pos,dist,dec_val,_cnt


	def iterROC(self,rev = False):
		### Start: Answer All Positive ###
		# desition value stored 2length tupple.
		# (isans,decision_value)
		# the desicion_value is positive dataset if isans is True

		# calculate number of data.
		# default: order by increase.
		psize = self._con.execute("select count(*) from valid where dist = 0;").fetchall()[0][0]
		nsize = self._con.execute("select count(*) from valid where dist >= %s and dist <= %s ;" % (self._low,self._up)).fetchall()[0][0]

		#per = {'TP':psize,'TN':0,'FP':nsize,'FN':0}
		per = performace(TP = psize,TN = 0,FP = nsize,FN = 0)

		for idch,pos,dist,dec_val in self.iter_dec(cnt,rev= rev):
			#x = div(per['FP'],[per['TN'],per['FP']])
			x = 1 - per.spf()
			#y = div(per['TP'],[per['TP'],per['FN']])
			y = per.sns()
			
			yield x,y,dec_val
			
			if dist == 0:
				# Positive Data
				#per['FN']+=1
				per.per['FN']+=1
				#per['TP']-=1
				per.per['TP']+=1
			elif self._low <= dist <= self._up:
				# Negative Data
				#per['FP']-=1
				per.per['FP']-=1
				#per['TN']+=1
				per.per['TN']-=1
		else:
			yield x,y,dec_val

	def iterRMS(self,rev = False,cnt = None):
		# For SVR
		# calculate number of data.
		# default: order by increase.
		f = lambda x,y : (x - y)**2
		psize = self._con.execute("select count(*) from valid where dist = 0;").fetchall()[0][0]
		nsize = self._con.execute("select count(*) from valid where dist >= %s and dist <= %s ;" % (self._low,self._up)).fetchall()[0][0]

		for idch,pos,dist,dec_val in self.iter_dec(cnt,rev= rev):
			if self._low <= dist <= self._up or dist == 0:
				yield idch,pos,min(dist,10),f(dec_val,dist),dec_val

			

	def iterPER(self,cnt,rev = False):
		### Start: Answer All Positive ###
		# desition value stored 2length tupple.
		# (isans,decision_value)
		# the desicion_value is positive dataset if isans is True

		# calculate number of data.
		# default: order by increase.
		if cnt is not None:
			sql_end = " and cnt = %s" % cnt
		else:
			sql_end = ";"
		psize = self._con.execute("select count(*) from valid where dist = 0 " + sql_end).fetchall()[0][0]
		nsize = self._con.execute("select count(*) from valid where dist >= %s and dist <= %s" % (self._low,self._up) + sql_end).fetchall()[0][0]

		#per = {'TP':psize,'TN':0,'FP':nsize,'FN':0}
		per = performace(TP = psize,TN = 0,FP = nsize,FN = 0)
		# For nest1
		
		#dec_vals = [(idch,pos,dist,f(dec_val,cnt)) for idch,pos,dist,dec_val,_cnt in self.iter_dec2(cnt,rev= rev)]
		dec_vals = [(idch,pos,dist,dec_val) for idch,pos,dist,dec_val,_cnt in self.iter_dec2(cnt,rev= rev)]
		#for idch,pos,dist,dec_val in self.iter_dec(cnt,rev= rev):
		for idch,pos,dist,dec_val in sorted(dec_vals,key = lambda x: x[3],reverse = rev):
			yield per,dec_val
			
			if dist == 0:
				# Positive Data
				#per['FN']+=1
				per.per['FN']+=1
				#per['TP']-=1
				per.per['TP']-=1
			elif self._low <= dist <= self._up:
				# Negative Data
				#per['FP']-=1
				per.per['FP']-=1
				#per['TN']+=1
				per.per['TN']+=1
		else:
			yield per,dec_val


	def iterPER2(self,rev = False,partids = None):
		### Start: Answer All Positive ###
		# desition value stored 2length tupple.
		# (isans,decision_value)
		# the desicion_value is positive dataset if isans is True

		# calculate number of data.
		# default: order by increase.
		tot_all = []
		for cnt in range(5):
			tot = [(idch,pos,dist,dec_val) for idch,pos,dist,dec_val,_cnt in self.iter_dec2(cnt = cnt,rev= rev) 
				   if (dist == 0 or self._low <= dist <= self._up)]
			av_dec = sum([dec_val for idch,pos,dist,dec_val in tot])/len(tot)
			sd_dec = sum([math.sqrt((dec_val - av_dec)**2) for idch,pos,dist,dec_val in tot])/len(tot)
			# convert decsion value to Z-score
			z_tot = [(idch,pos,dist,(dec_val - av_dec)/sd_dec) for idch,pos,dist,dec_val in tot]
			tot_all += z_tot

		psize = len([dec_val for idch,pos,dist,dec_val in tot_all if dist == 0])
		nsize = len([dec_val for idch,pos,dist,dec_val in tot_all if self._low <= dist <= self._up])
		#per = {'TP':psize,'TN':0,'FP':nsize,'FN':0}
		per = performace(TP = psize,TN = 0,FP = nsize,FN = 0)
		for idch,pos,dist,dec_val in sorted(tot_all,key = lambda x:x[3],reverse = rev):
			yield per,dec_val
			
			if dist == 0:
				# Positive Data
				#per['FN']+=1
				per.per['FN']+=1
				#per['TP']-=1
				per.per['TP']-=1
			elif self._low <= dist <= self._up:
				# Negative Data
				#per['FP']-=1
				per.per['FP']-=1
				#per['TN']+=1
				per.per['TN']+=1
		else:
			yield per,dec_val

	def iterROC2(self,cnt,rev = False):
		if rev:
			prev_dec = float("-inf")
		else:
			prev_dec = float("inf")
		
		for per,dec_val in self.iterPER(cnt,rev):
			if prev_dec != dec_val:
				yield 1-per.spf(),per.sns(),dec_val
			prev_dec = dec_val
		else:
			yield 1-per.spf(),per.sns(),dec_val

	def iterROC3(self,rev = False,partids = None):
		if rev:
			prev_dec = float("-inf")
		else:
			prev_dec = float("inf")
		
		for per,dec_val in self.iterPER2(rev = rev,partids = partids):
			if prev_dec != dec_val:
				yield 1-per.spf(),per.sns(),dec_val
			prev_dec = dec_val
		else:
			yield 1-per.spf(),per.sns(),dec_val

	def _AUC(self,cnt,rev = False):
		x1,y1 = None,None
		AUC = 0
		for x,y,dec in self.iterROC2(cnt,rev = rev):
			if x1 is None or y1 is None:
				x1,y1 = x,y
			AUC += abs(x - x1)*(y + y1)/2.0
			x1,y1 = x,y
		return AUC
	
	def AUC(self,cnt):
		v_auc = self._AUC(cnt,rev = False)
		return max([v_auc,1 - v_auc])

	def _AUC2(self,rev = False):
		x1,y1 = None,None
		AUC = 0
		for x,y,dec in self.iterROC3(rev = rev):
			if x1 is None or y1 is None:
				x1,y1 = x,y
			AUC += abs(x - x1)*(y + y1)/2.0
			x1,y1 = x,y
		return AUC
	
	def AUC2(self):
		v_auc = self._AUC2(rev = False)
		return max([v_auc,1 - v_auc])

	def iterMCC(self,cnt,rev = False):
		for per,dec_val in self.iterPER(cnt,rev):
			#f1 = 2*(per.ppv() * per.npv())/(per.ppv() + per.npv())
			#yield dec_val,f1
			# Base Error Rate
			#yield dec_val,1 - per.ber()
			yield dec_val,per.mcc()
	
	def optThr(self,rev = False,cnt = None):
		result = {"max_MCC":float("-inf"),"thr":None}
		for dec_val,mcc in self.iterMCC(cnt = cnt,rev = rev):
			if mcc is None:
				continue
			elif result["max_MCC"] < mcc:
				result["max_MCC"] = mcc
				result["thr"] = [dec_val]
			elif result["max_MCC"] == mcc:
				#result["thr"].append(dec_val)
				pass
		return result

	def summary(self,rev = False,cnt = None):
		result = self.optThr(rev,cnt)
		if not rev:
			crit = lambda dec_val,thr: dec_val >= thr
		else:
			crit = lambda dec_val,thr: dec_val <= thr
		
		for thr in result["thr"]:
			#f = lambda x,cnt: x*-1 if cnt == 4  else x
			tot = [(dec_val,dist) for idch,pos,dist,dec_val,cnt in self.iter_dec2(cnt = cnt,rev = rev) if dist == 0 or self._low <= dist <= self._up]
			#tot = [(f(dec_val,cnt),dist) for idch,pos,dist,dec_val,cnt in self.iter_dec2(cnt = cnt,rev = rev) if dist == 0 or self._low <= dist <= self._up]
			TP = len([dec_val for dec_val,dist in tot if dist == 0 and crit(dec_val,thr)])
			FN = len([dec_val for dec_val,dist in tot if dist == 0 and not crit(dec_val,thr)])
			FP = len([dec_val for dec_val,dist in tot if self._low <= dist <= self._up and crit(dec_val,thr)])
			TN = len([dec_val for dec_val,dist in tot if self._low <= dist <= self._up and not crit(dec_val,thr)])
			yield thr,performace(TP = TP,TN = TN,FP = FP,FN = FN)

	def iterPR(self,cnt,rev = False):
		# For Presicion Recall curve
		if rev:
			prev_dec = float("-inf")
		else:
			prev_dec = float("inf")
		
		for per,dec_val in self.iterPER(cnt,rev):
			if prev_dec != dec_val:
				yield per.ppv(),per.sns(),dec_val
			prev_dec = dec_val
		else:
			yield per.ppv(),per.sns(),dec_val
			
